import logging
import asyncio
import os
import sys
from collections import defaultdict
from aiogram import Bot, Dispatcher, F, types
from aiogram.filters import Command
from aiogram.types import Message, ReplyKeyboardMarkup, KeyboardButton, InlineKeyboardButton, InlineKeyboardMarkup
from config import BOT_TOKEN
from utils.gpt_client import evaluate_portfolio
from aiogram.fsm.storage.memory import MemoryStorage
from aiogram.fsm.context import FSMContext
from aiogram.fsm.state import State, StatesGroup
from aiogram.types import BufferedInputFile
import re
import html


# –û–≥—Ä–∞–Ω–∏—á–µ–Ω–∏–µ —Ç–µ–ª–µ–≥—Ä–∞–º–º–∞ –Ω–∞ –¥–ª–∏–Ω—É —Å–æ–æ–±—â–µ–Ω–∏—è –≤ –±–æ—Ç–µ
TG_MSG_LIMIT = 4096
SAFE_LIMIT = 4000 # –Ω–µ–±–æ–ª—å—à–æ–π –∑–∞–ø–∞—Å, —á—Ç–æ–±—ã –Ω–µ —É–ø–µ—Ä–µ—Ç—å—Å—è –≤ –ø—Ä–µ–¥–µ–ª


# –ë–æ—Ç
bot = Bot(token=BOT_TOKEN)
storage = MemoryStorage()
dp = Dispatcher(bot=bot, storage=storage)

# –õ–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ
logging.basicConfig(level=logging.INFO)

# –î–ª—è —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è —Ä–µ–∂–∏–º–∞
class ModeState(StatesGroup):
    mode = State()  # –†–µ–∂–∏–º, –∫–æ—Ç–æ—Ä—ã–π –±—É–¥–µ—Ç –≤—ã–±—Ä–∞–Ω

# –•—Ä–∞–Ω–∏–ª–∏—â–µ —Ñ–æ—Ç–æ –∞–ª—å–±–æ–º–æ–≤
user_albums = defaultdict(list)
album_tasks = {}


# –°–ª–æ–≤–∞—Ä—å —Å —Ä–µ–∂–∏–º–∞–º–∏ –∏ –∏—Ö –Ω–∞–∑–≤–∞–Ω–∏—è–º–∏
MODE_MAPPING = {
    "basic": "Basic",
    "alfa3d": "Alfa3D",
    # "advanced": "Advanced"
}

# –§—É–Ω–∫—Ü–∏—è –¥–ª—è —Å–æ–∑–¥–∞–Ω–∏—è Inline –∫–ª–∞–≤–∏–∞—Ç—É—Ä—ã —Å –∫–Ω–æ–ø–∫–∞–º–∏ –Ω–∞ –æ—Å–Ω–æ–≤–µ —Å–ª–æ–≤–∞—Ä—è —Ä–µ–∂–∏–º–æ–≤
def get_mode_keyboard():  

    inline_keyboard = []

    # –î–æ–±–∞–≤–ª—è–µ–º –∫–Ω–æ–ø–∫–∏ –¥–ª—è –∫–∞–∂–¥–æ–≥–æ —Ä–µ–∂–∏–º–∞ –≤ —Å–ª–æ–≤–∞—Ä—å
    for mode_key, mode_name in MODE_MAPPING.items():
        button = InlineKeyboardButton(text=mode_name, callback_data=f"mode_{mode_key}")
        inline_keyboard.append(button)

    # –†–∞–∑–±–∏–≤–∞–µ–º –Ω–∞ —Å—Ç—Ä–æ–∫–∏ –ø–æ 3 –∫–Ω–æ–ø–∫–∏ –≤ –∫–∞–∂–¥–æ–π —Å—Ç—Ä–æ–∫–µ
    rows = [inline_keyboard[i:i+3] for i in range(0, len(inline_keyboard), 3)]

    # –°–æ–∑–¥–∞–µ–º –∫–ª–∞–≤–∏–∞—Ç—É—Ä—É, –ø–µ—Ä–µ–¥–∞–≤–∞—è inline_keyboard
    keyboard = InlineKeyboardMarkup(inline_keyboard=rows)  # row_width –±—É–¥–µ—Ç –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ —Ä–∞—Å—Å—á–∏—Ç–∞–Ω
    return keyboard


# –û–±—Ä–∞–±–æ—Ç—á–∏–∫ –∫–æ–º–∞–Ω–¥—ã /start, —á—Ç–æ–±—ã –ø–æ–∫–∞–∑–∞—Ç—å –∫–Ω–æ–ø–∫–∏ –≤—ã–±–æ—Ä–∞ —Ä–µ–∂–∏–º–∞
@dp.message(Command("start"))
async def start_cmd(message: Message):
        await message.answer(
            "–ü—Ä–∏–≤–µ—Ç! –û—Ç–ø—Ä–∞–≤—å –æ–¥–Ω–æ –∏–ª–∏ –Ω–µ—Å–∫–æ–ª—å–∫–æ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π (–º–æ–∂–Ω–æ –∞–ª—å–±–æ–º–æ–º), "
            "–∏ —è –æ—Ü–µ–Ω—é –∏—Ö –∫–∞–∫ –µ–¥–∏–Ω–æ–µ –ø–æ—Ä—Ç—Ñ–æ–ª–∏–æ üñºÔ∏è. "
            "–ü–æ —É–º–æ–ª—á–∞–Ω–∏—é –±–æ—Ç –æ—Ü–µ–Ω–∏–≤–∞–µ—Ç –±–µ–∑ –∫–æ–Ω—Ç–µ–∫—Å—Ç–∞, –Ω–æ –µ—Å—Ç—å —Ä–µ–∂–∏–º Alfa3D, "
            "–∫–æ—Ç–æ—Ä—ã–π –æ—Ü–µ–Ω–∏–≤–∞–µ—Ç –∫–∞—Ä—Ç–∏–Ω–∫–∏ —Å 3D –≤ —Å—Ç–∏–ª–µ —Ç–≥-–∫–∞–Ω–∞–ª–∞ –ê–ª—å—Ñ–∞-–ë–∞–Ω–∫–∞"
            , reply_markup=get_mode_keyboard()
        )



# –û–±—Ä–∞–±–æ—Ç–∫–∞ –≤—ã–±—Ä–∞–Ω–Ω–æ–≥–æ —Ä–µ–∂–∏–º–∞ —á–µ—Ä–µ–∑ callback
@dp.callback_query(lambda c: c.data.startswith("mode_"))
async def mode_handler(callback_query: types.CallbackQuery, state: FSMContext):
    mode = callback_query.data.replace("mode_", "")

    # –°–æ—Ö—Ä–∞–Ω—è–µ–º —Ä–µ–∂–∏–º –≤ FSMContext
    await state.update_data(mode=mode)

    if mode == "basic":
        response = "–í—ã –≤—ã–±—Ä–∞–ª–∏ —Ä–µ–∂–∏–º 'Basic'. –û—Ç–ø—Ä–∞–≤—å—Ç–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ –∏–ª–∏ –Ω–µ—Å–∫–æ–ª—å–∫–æ –¥–ª—è –æ—Ü–µ–Ω–∫–∏."
    elif mode == "alfa3d":
        response = "–í—ã –≤—ã–±—Ä–∞–ª–∏ —Ä–µ–∂–∏–º 'Alfa3D'. –û—Ç–ø—Ä–∞–≤—å—Ç–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è –∏–ª–∏ –Ω–µ—Å–∫–æ–ª—å–∫–æ –¥–ª—è –æ—Ü–µ–Ω–∫–∏ —Å —Ç–æ—á–∫–∏ –∑—Ä–µ–Ω–∏—è 3D –≤ —Å—Ç–∏–ª–µ –ê–ª—å—Ñ—ã."
    # elif mode == "advanced":
    #     response = "–í—ã –≤—ã–±—Ä–∞–ª–∏ —Ä–µ–∂–∏–º 'Advanced'. –û—Ç–ø—Ä–∞–≤—å—Ç–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è –¥–ª—è –≥–ª—É–±–æ–∫–æ–≥–æ –∞–Ω–∞–ª–∏–∑–∞."

    # –û—Ç–≤–µ—Ç –Ω–∞ callback
    await callback_query.answer()
    await callback_query.message.answer(response)


# –û–±—Ä–∞–±–æ—Ç–∫–∞ —Ñ–æ—Ç–æ–≥—Ä–∞—Ñ–∏–π —Å –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ–º –≤—ã–±—Ä–∞–Ω–Ω–æ–≥–æ —Ä–µ–∂–∏–º–∞
@dp.message(F.photo)
async def handle_photos(message: Message, state: FSMContext):
    """
    –û–±—Ä–∞–±–æ—Ç–∫–∞ –æ–¥–∏–Ω–æ—á–Ω—ã—Ö —Ñ–æ—Ç–æ –∏ –∞–ª—å–±–æ–º–æ–≤ —Å –æ–∂–∏–¥–∞–Ω–∏–µ–º –≤—Å–µ—Ö –∫–∞–¥—Ä–æ–≤.
    """
    os.makedirs("downloads", exist_ok=True)

    # –°–∫–∞—á–∏–≤–∞–µ–º —Ñ–æ—Ç–æ –≤ –º–∞–∫—Å–∏–º–∞–ª—å–Ω–æ–º –∫–∞—á–µ—Å—Ç–≤–µ
    file_info = await bot.get_file(message.photo[-1].file_id)
    file_path = f"downloads/{message.photo[-1].file_id}.jpg"
    await bot.download_file(file_info.file_path, destination=file_path)

    # –∫–ª—é—á –≥—Ä—É–ø–ø–∏—Ä–æ–≤–∫–∏: –∞–ª—å–±–æ–º –∏–ª–∏ "solo" –ø–æ —á–∞—Ç—É
    media_key = message.media_group_id or f"solo-{message.chat.id}"
    group_key = f"{message.chat.id}:{media_key}"

    # –Ω–∞–∫–∞–ø–ª–∏–≤–∞–µ–º —Ñ–∞–π–ª
    user_albums[group_key].append(file_path)

    # –¥–µ–±–∞—É–Ω—Å: –æ—Ç–º–µ–Ω—è–µ–º —Å—Ç–∞—Ä—É—é –∑–∞–¥–∞—á—É, —Å—Ç–∞–≤–∏–º –Ω–æ–≤—É—é
    prev = album_tasks.get(group_key)
    if prev and not prev.done():
        prev.cancel()

    album_tasks[group_key] = asyncio.create_task(
        process_album_after_delay(group_key, message, state)
    )


ALBUM_WAIT_SEC = 0.8

async def process_album_after_delay(group_key: str, message: Message, state: FSMContext, delay: float =ALBUM_WAIT_SEC):
    """
    –ñ–¥—ë—Ç delay —Å–µ–∫—É–Ω–¥, –ø–æ—Å–ª–µ —á–µ–≥–æ –æ—Ç–ø—Ä–∞–≤–ª—è–µ—Ç –∞–ª—å–±–æ–º –≤ GPT.
    """
    try:
        await asyncio.sleep(delay)  # –µ—Å–ª–∏ –ø—Ä–∏—à–ª–æ –µ—â—ë —Ñ–æ—Ç–æ, —ç—Ç–∞ –∑–∞–¥–∞—á–∞ –±—É–¥–µ—Ç –æ—Ç–º–µ–Ω–µ–Ω–∞
    except asyncio.CancelledError:
        return

    images = user_albums.pop(group_key, [])
    album_tasks.pop(group_key, None)

    if not images:
        return

    await process_portfolio(message, images, state)


async def process_portfolio(message: Message, image_paths: list[str], state: FSMContext):
    """
    –û—Ç–ø—Ä–∞–≤–∫–∞ —Ñ–æ—Ç–æ –≤ GPT –∏ –≤–æ–∑–≤—Ä–∞—Ç —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é.
    """
    await message.answer("‚è≥ –ê–Ω–∞–ª–∏–∑–∏—Ä—É—é –ø–æ—Ä—Ç—Ñ–æ–ª–∏–æ, –ø–æ–¥–æ–∂–¥–∏—Ç–µ –Ω–µ–º–Ω–æ–≥–æ...")

    # —Ä–µ–∂–∏–º –∏–∑ FSM, –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é basic
    user_data = await state.get_data()
    mode = user_data.get("mode", "basic")  # –ï—Å–ª–∏ —Ä–µ–∂–∏–º–∞ –Ω–µ—Ç, –∏—Å–ø–æ–ª—å–∑—É–µ–º 'basic' –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é

    try:
        feedback = await evaluate_portfolio(mode, image_paths)
    except Exception as e:
        feedback = f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ—Ü–µ–Ω–∫–µ –ø–æ—Ä—Ç—Ñ–æ–ª–∏–æ: {e}"

    feedback_with_markdown = gpt_markdown_to_telegram_html(feedback)

    await send_feedback(message, feedback)

    # –£–¥–∞–ª—è–µ–º –≤—Ä–µ–º–µ–Ω–Ω—ã–µ —Ñ–∞–π–ª—ã
    for path in image_paths:
        try:
            os.remove(path)
        except:
            pass


async def send_feedback(message, feedback: str):
    # –ï—Å–ª–∏ –∫–æ—Ä–æ—Ç–∫–æ ‚Äî —à–ª—ë–º –∫–∞–∫ –µ—Å—Ç—å —Å HTML (–∫–∞–∫ —É –≤–∞—Å)
    if len(feedback) <= SAFE_LIMIT:
        await message.answer(f"üìä –û—Ü–µ–Ω–∫–∞ –ø–æ—Ä—Ç—Ñ–æ–ª–∏–æ:\n\n{feedback}", parse_mode="HTML")
        return

    # —Ä–µ–∂–µ–º –Ω–∞ —á–∞—Å—Ç–∏ (–±–µ–∑ parse_mode, —á—Ç–æ–±—ã –Ω–µ –ø–æ—Ä–≤–∞—Ç—å HTML)
    chunks = split_for_telegram(feedback, SAFE_LIMIT)
    total = len(chunks)
    for i, chunk in enumerate(chunks, 1):
        prefix = "üìä –û—Ü–µ–Ω–∫–∞ –ø–æ—Ä—Ç—Ñ–æ–ª–∏–æ" if i == 1 else "–ü—Ä–æ–¥–æ–ª–∂–µ–Ω–∏–µ"
        await message.answer(f"{prefix} ({i}/{total}):\n\n{chunk}")  # –±–µ–∑ parse_mode



@dp.message()
async def handle_other(message: Message):
    await message.answer("–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –æ—Ç–ø—Ä–∞–≤—å –æ–¥–Ω–æ –∏–ª–∏ –Ω–µ—Å–∫–æ–ª—å–∫–æ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π.")

async def main():
    try:
        await dp.start_polling(bot)
    except Exception as e:
        logging.error(f"–ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –∑–∞–ø—É—Å–∫–µ: {e}")
        pass
    finally:
        await bot.session.close()


if __name__ == "__main__":
    asyncio.run(main())


# =====TG-MARKDOWN-UTILITIES

def gpt_markdown_to_telegram_html(markdown_text: str) -> str:
    # –≠–∫—Ä–∞–Ω–∏—Ä—É–µ–º HTML, —á—Ç–æ–±—ã –∏–∑–±–µ–∂–∞—Ç—å –∫–æ–Ω—Ñ–ª–∏–∫—Ç–æ–≤
    text = html.escape(markdown_text)

    # –ñ–∏—Ä–Ω—ã–π —Ç–µ–∫—Å—Ç **...**
    text = re.sub(r"\*\*(.+?)\*\*", r"<b>\1</b>", text)

    # –ö—É—Ä—Å–∏–≤ *...*
    text = re.sub(r"\*(.+?)\*", r"<i>\1</i>", text)

    # –ú–∞—Ä–∫–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ —Å–ø–∏—Å–∫–∏
    text = re.sub(r"^\s*-\s+", "‚Ä¢ ", text, flags=re.MULTILINE)

    # –ù—É–º–µ—Ä–æ–≤–∞–Ω–Ω—ã–µ —Å–ø–∏—Å–∫–∏ (–±–µ–∑ —Å—Å—ã–ª–æ–∫ –Ω–∞ –≥—Ä—É–ø–ø—ã)
    text = re.sub(r"^\s*(\d+)\.\s+", r"\1. ", text, flags=re.MULTILINE)

    # <br> ‚Üí –ø–µ—Ä–µ–Ω–æ—Å —Å—Ç—Ä–æ–∫–∏
    text = text.replace("<br>", "\n")

    # –£–±–∏—Ä–∞–µ–º –ª–∏—à–Ω–∏–µ –ø–µ—Ä–µ–Ω–æ—Å—ã
    text = re.sub(r"\n{3,}", "\n\n", text)

    return text.strip()


def split_for_telegram(text: str, limit: int = SAFE_LIMIT) -> list[str]:
    """–†–µ–∂–µ–º —Ç–µ–∫—Å—Ç ¬´–ø–æ-—á–µ–ª–æ–≤–µ—á–µ—Å–∫–∏¬ª: –ø–æ \n, –∑–∞—Ç–µ–º –ø–æ –ø—Ä–æ–±–µ–ª—É, –∏–Ω–∞—á–µ –∂—ë—Å—Ç–∫–∏–π —Ä–∞–∑—Ä–µ–∑."""
    parts = []
    while text:
        if len(text) <= limit:
            parts.append(text)
            break
        cut = text.rfind("\n", 0, limit)
        if cut == -1:
            cut = text.rfind(" ", 0, limit)
        if cut == -1:
            cut = limit
        parts.append(text[:cut])
        text = text[cut:].lstrip("\n ")
    return parts
